// src/constants.ts
var CHUNK_NUM = 3;
var COL_NUM = 9;
var CELL_NUMBER = 81;

// src/Cell.ts
var DEFAULT_CANDIDATES = 1022;
var Cell = class {
  num = 0;
  candidatesCount = COL_NUM;
  prev;
  next;
  pos;
  candidates = DEFAULT_CANDIDATES;
  relatedCells = [];
  changedCells = [];
  constructor(pos) {
    this.pos = pos;
    this.prev = this;
    this.next = this;
  }
  setRelatedCells(cells2) {
    const row = Math.floor(this.pos / COL_NUM);
    const col = this.pos % COL_NUM;
    const area33top = Math.floor(row / CHUNK_NUM) * CHUNK_NUM;
    const area33left = Math.floor(col / CHUNK_NUM) * CHUNK_NUM;
    for (let i = 0; i < COL_NUM; i++) {
      const row33 = area33top + Math.floor(i / CHUNK_NUM);
      const col33 = area33left + i % CHUNK_NUM;
      this.addRelatedCell(cells2, row, i);
      this.addRelatedCell(cells2, i, col);
      this.addRelatedCell(cells2, row33, col33);
    }
  }
  init() {
    this.num = 0;
    this.candidates = DEFAULT_CANDIDATES;
    this.candidatesCount = COL_NUM;
    this.changedCells.splice(0);
  }
  setNum(num) {
    const mask = 1 << num;
    if ((this.candidates & mask) === 0) {
      return false;
    }
    this.num = num;
    for (const cell of this.relatedCells) {
      if (cell.num === 0 && cell.candidates & mask) {
        if (cell.candidatesCount === 1) {
          this.resetNum();
          return false;
        }
        cell.candidates ^= mask;
        cell.candidatesCount--;
        this.changedCells.push(cell);
      }
    }
    return true;
  }
  resetNum() {
    const mask = 1 << this.num;
    this.changedCells.forEach((cell) => {
      cell.candidates ^= mask;
      cell.candidatesCount++;
    });
    this.changedCells.splice(0);
    this.num = 0;
  }
  addRelatedCell(cells2, row, col) {
    const pos = row * COL_NUM + col;
    if (pos !== this.pos) {
      const cell = cells2[pos];
      if (!this.relatedCells.includes(cell)) {
        this.relatedCells.push(cell);
      }
    }
  }
};

// src/EmptyList.ts
var MIN_LENGTH_INITIAL = COL_NUM + 1;
var EmptyList = class extends Cell {
  length = 0;
  constructor() {
    super(-1);
  }
  push(cell) {
    cell.prev = this.prev;
    cell.next = this;
    cell.prev.next = cell;
    this.prev = cell;
    this.length++;
  }
  pop() {
    let cell = this;
    let selectedCell = this;
    let minLength = MIN_LENGTH_INITIAL;
    while ((cell = cell.next) !== this) {
      if (cell.candidatesCount === 1) {
        selectedCell = cell;
        break;
      }
      if (cell.candidatesCount < minLength) {
        minLength = cell.candidatesCount;
        selectedCell = cell;
      }
    }
    selectedCell.prev.next = selectedCell.next;
    selectedCell.next.prev = selectedCell.prev;
    this.length--;
    return selectedCell;
  }
  restore(cell) {
    cell.prev.next = cell;
    cell.next.prev = cell;
    this.length++;
  }
  clear() {
    this.prev = this;
    this.next = this;
    this.length = 0;
  }
};

// src/index.ts
var SolveStatus = {
  invalidLength: 1,
  noEmpty: 2,
  duplicated: 3,
  unsolvable: 4,
  outOfRange: 5
};
var validNumList = [...Array(COL_NUM + 1)].map((_, i) => i);
var emptyList = new EmptyList();
var cells = [...Array(CELL_NUMBER)].map((_, i) => new Cell(i));
cells.forEach((cell) => cell.setRelatedCells(cells));
var solve = (numArray) => {
  if (numArray.length !== CELL_NUMBER) {
    return { success: false, status: SolveStatus.invalidLength };
  }
  cells.forEach((cell) => cell.init());
  emptyList.clear();
  for (const cell of cells) {
    const num = numArray[cell.pos];
    if (!validNumList.includes(num)) {
      return { success: false, status: SolveStatus.outOfRange };
    }
    if (num === 0) {
      emptyList.push(cell);
    } else if (!cell.setNum(num)) {
      return { success: false, status: SolveStatus.duplicated };
    }
  }
  if (emptyList.length === 0) {
    return { success: false, status: SolveStatus.noEmpty };
  }
  if (!solveRecursive()) {
    return { success: false, status: SolveStatus.unsolvable };
  }
  return { success: true, solution: cells.map((cell) => cell.num) };
};
var solveRecursive = () => {
  const cell = emptyList.pop();
  for (let i = 1; i <= 9; i++) {
    if (cell.setNum(i)) {
      if (emptyList.length === 0 || solveRecursive()) {
        return true;
      }
      cell.resetNum();
    }
  }
  emptyList.restore(cell);
  return false;
};
export {
  SolveStatus,
  solve
};
