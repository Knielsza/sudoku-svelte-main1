{
  "version": 3,
  "sources": ["../../sudoku-solver-ts/dist/index.js"],
  "sourcesContent": ["// src/constants.ts\nvar CHUNK_NUM = 3;\nvar COL_NUM = 9;\nvar CELL_NUMBER = 81;\n\n// src/Cell.ts\nvar DEFAULT_CANDIDATES = 1022;\nvar Cell = class {\n  num = 0;\n  candidatesCount = COL_NUM;\n  prev;\n  next;\n  pos;\n  candidates = DEFAULT_CANDIDATES;\n  relatedCells = [];\n  changedCells = [];\n  constructor(pos) {\n    this.pos = pos;\n    this.prev = this;\n    this.next = this;\n  }\n  setRelatedCells(cells2) {\n    const row = Math.floor(this.pos / COL_NUM);\n    const col = this.pos % COL_NUM;\n    const area33top = Math.floor(row / CHUNK_NUM) * CHUNK_NUM;\n    const area33left = Math.floor(col / CHUNK_NUM) * CHUNK_NUM;\n    for (let i = 0; i < COL_NUM; i++) {\n      const row33 = area33top + Math.floor(i / CHUNK_NUM);\n      const col33 = area33left + i % CHUNK_NUM;\n      this.addRelatedCell(cells2, row, i);\n      this.addRelatedCell(cells2, i, col);\n      this.addRelatedCell(cells2, row33, col33);\n    }\n  }\n  init() {\n    this.num = 0;\n    this.candidates = DEFAULT_CANDIDATES;\n    this.candidatesCount = COL_NUM;\n    this.changedCells.splice(0);\n  }\n  setNum(num) {\n    const mask = 1 << num;\n    if ((this.candidates & mask) === 0) {\n      return false;\n    }\n    this.num = num;\n    for (const cell of this.relatedCells) {\n      if (cell.num === 0 && cell.candidates & mask) {\n        if (cell.candidatesCount === 1) {\n          this.resetNum();\n          return false;\n        }\n        cell.candidates ^= mask;\n        cell.candidatesCount--;\n        this.changedCells.push(cell);\n      }\n    }\n    return true;\n  }\n  resetNum() {\n    const mask = 1 << this.num;\n    this.changedCells.forEach((cell) => {\n      cell.candidates ^= mask;\n      cell.candidatesCount++;\n    });\n    this.changedCells.splice(0);\n    this.num = 0;\n  }\n  addRelatedCell(cells2, row, col) {\n    const pos = row * COL_NUM + col;\n    if (pos !== this.pos) {\n      const cell = cells2[pos];\n      if (!this.relatedCells.includes(cell)) {\n        this.relatedCells.push(cell);\n      }\n    }\n  }\n};\n\n// src/EmptyList.ts\nvar MIN_LENGTH_INITIAL = COL_NUM + 1;\nvar EmptyList = class extends Cell {\n  length = 0;\n  constructor() {\n    super(-1);\n  }\n  push(cell) {\n    cell.prev = this.prev;\n    cell.next = this;\n    cell.prev.next = cell;\n    this.prev = cell;\n    this.length++;\n  }\n  pop() {\n    let cell = this;\n    let selectedCell = this;\n    let minLength = MIN_LENGTH_INITIAL;\n    while ((cell = cell.next) !== this) {\n      if (cell.candidatesCount === 1) {\n        selectedCell = cell;\n        break;\n      }\n      if (cell.candidatesCount < minLength) {\n        minLength = cell.candidatesCount;\n        selectedCell = cell;\n      }\n    }\n    selectedCell.prev.next = selectedCell.next;\n    selectedCell.next.prev = selectedCell.prev;\n    this.length--;\n    return selectedCell;\n  }\n  restore(cell) {\n    cell.prev.next = cell;\n    cell.next.prev = cell;\n    this.length++;\n  }\n  clear() {\n    this.prev = this;\n    this.next = this;\n    this.length = 0;\n  }\n};\n\n// src/index.ts\nvar SolveStatus = {\n  invalidLength: 1,\n  noEmpty: 2,\n  duplicated: 3,\n  unsolvable: 4,\n  outOfRange: 5\n};\nvar validNumList = [...Array(COL_NUM + 1)].map((_, i) => i);\nvar emptyList = new EmptyList();\nvar cells = [...Array(CELL_NUMBER)].map((_, i) => new Cell(i));\ncells.forEach((cell) => cell.setRelatedCells(cells));\nvar solve = (numArray) => {\n  if (numArray.length !== CELL_NUMBER) {\n    return { success: false, status: SolveStatus.invalidLength };\n  }\n  cells.forEach((cell) => cell.init());\n  emptyList.clear();\n  for (const cell of cells) {\n    const num = numArray[cell.pos];\n    if (!validNumList.includes(num)) {\n      return { success: false, status: SolveStatus.outOfRange };\n    }\n    if (num === 0) {\n      emptyList.push(cell);\n    } else if (!cell.setNum(num)) {\n      return { success: false, status: SolveStatus.duplicated };\n    }\n  }\n  if (emptyList.length === 0) {\n    return { success: false, status: SolveStatus.noEmpty };\n  }\n  if (!solveRecursive()) {\n    return { success: false, status: SolveStatus.unsolvable };\n  }\n  return { success: true, solution: cells.map((cell) => cell.num) };\n};\nvar solveRecursive = () => {\n  const cell = emptyList.pop();\n  for (let i = 1; i <= 9; i++) {\n    if (cell.setNum(i)) {\n      if (emptyList.length === 0 || solveRecursive()) {\n        return true;\n      }\n      cell.resetNum();\n    }\n  }\n  emptyList.restore(cell);\n  return false;\n};\nexport {\n  SolveStatus,\n  solve\n};\n"],
  "mappings": "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",
  "names": []
}
